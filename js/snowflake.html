<!DOCTYPE html>
<html>
<head><title>Snowflake to STL</title></head>
</head>
<body>
Snowflake name: <input id="name" type="text" value="morptel"/> (find it <a href="http://mkweb.bcgsc.ca/snowflakes">here</a>)<br/>
Diameter: <input id="diameter" type="number" value="190" min="0.1" step="5" max="100000"/>mm <br/>
Minimum thickness: <input id="thinnest" type="number" step="0.1" value="1.5" min="0.1" max="100000"/>mm<br/> 
Maximum thickness: <input id="thickest" type="number" step="0.1" value="4" min="0.1" max="100000"/>mm<br/> 
Number of levels: <input id="levels" type="number" step="1" min="1" max="1000" value="1"/><br/>
<button id="Go" onClick="load()">Generate!</button><br/><br/>
<div id="output"></div><br/>
<div id="progress"></div>
</body>

<script>
// TODO: fix multiple Generate presses

function corsCircumvent(url) {
    //return "http://crossorigin.me/"+encodeURIComponent(url)
    //return "http://cors-proxy.htmldriven.com/?url="+encodeURIComponent(url)
    return "http://api.allorigins.ml/get?method=raw&url="+encodeURIComponent(url)+"&callback=?"
}

var TRIANGLE_SIZE = (3+3*3)*4+2
var diameter
var minThickness
var maxThickness
var levels
var name
var globalMesh

var CORNERS = [[1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1], [1, -1]]

function displayX(x,y,size) {
    return ((x-2*size) + (y-2*size) / 2.) * Math.sqrt(3)
}

function displayY(x,y,size) {
    return (y-2*size) * 1.5
}

function getScale(raster, size) {
    var maxRadiusSq = 0;
    for (var x = 0 ; x < size ; x++)
        for (var y = 0; y < size ; y++)
            if (raster[x][y]>0)
                maxRadiusSq = Math.max(maxRadiusSq,Math.pow(displayX(x,y,size),2)+Math.pow(displayY(x,y,size),2))
    return diameter/(2*(0.5+Math.sqrt(maxRadiusSq)))
}

function addLevel(mesh, raster, size, prevHeight, height, prevThickness, thickness) {
    var maxCoord = 100000
    
    var scale = getScale(raster, size)

    function xyToDisplay(xy) {
        return [scale*displayX(xy[0],xy[1],size),scale*displayY(xy[0],xy[1],size)]
    }

    function raiseTo(a,h) {
        return [a[0],a[1],h]
    }
    
    function addTriangleAt(h, a, b, c) {
        mesh.push(raiseTo(a,h),raiseTo(b,h),raiseTo(c,h)) 
    }
    
    function addSideMesh(a, b) {
        mesh.push([raiseTo(a,prevThickness), raiseTo(b,prevThickness), raiseTo(b,thickness)])
        mesh.push([raiseTo(a,prevThickness), raiseTo(b,thickness), raiseTo(a,thickness)])
    }

    var segmentSet = new Set()
    
    for (var x = 0 ; x < size; x++)
        for (var y = 0 ; y < size ; y++) {
            if (prevHeight < raster[x][y] && raster[x][y] <= height) {
                var center = xyToDisplay([2*x,2*y])
                for (var i=0; i<6; i++) {
                    var c0 = CORNERS[i]
                    var c1 = CORNERS[(i+1)%6]
                    var p0 = [2*x+c0[0],2*y+c0[1]]
                    var p1 = [2*x+c1[0],2*y+c1[1]]
                    
                    var rev = p1[0]+","+p1[1]+","+p0[0]+","+p0[1]
                    
                    if (segmentSet.has(rev)) {
                        segmentSet.delete(rev)
                        console.log("del")
                    }
                    else {
                        segmentSet.add(p0[0]+","+p0[1]+","+p1[0]+","+p1[1])
                    }
                    
                    addTriangleAt(0, center, xyToDisplay(p1), xyToDisplay(p0))
                    addTriangleAt(thickness, center, xyToDisplay(p0), xyToDisplay(p1))
                }
            }
        }
        
    segments = []
     
    segmentSet.forEach(function(seg) {
        var points = seg.split(",")
        addSideMesh(xyToDisplay([parseInt(points[0]),parseInt(points[1])]), xyToDisplay([parseInt(points[2]),parseInt(points[3])]))
    })
    
    console.log(mesh.length)
}

function processRaster(raster, size) {
    window.document.getElementById("progress").innerHTML = "Meshing..."

    var minHeight = Number.POSITIVE_INFINITY
    var maxHeight = Number.NEGATIVE_INFINITY
    
    for (var x = 0 ; x < size ; x++) {
        for (var y = 0; y<size ; y++) {
            if (raster[x][y] > 0) {
                minHeight = Math.min(minHeight, raster[x][y])
                maxHeight = Math.max(maxHeight, raster[x][y])
            }
        }
    }

    var mesh = []
    var prevHeight = 0
    var prevThickness = 0
    
    for (var level=0; level<levels; level++) {
        var thickness
        if (levels == 1) {
            thickness = maxThickness
        }
        else {
            thickness = minThickness+level*(maxThickness-minThickness)/(levels-1)
        }
        var height = minHeight+(level+1)*(maxHeight-minHeight)/levels
        console.log("Mesh level "+(level+1)+"/"+levels+" "+prevHeight+" "+height)
        if (level == levels-1)
            height = Number.POSITIVE_INFINITY;
        addLevel(mesh, raster, size, prevHeight, height, prevThickness, thickness)
        prevHeight = height
        prevThickness = thickness
    }
    console.log("meshing done",mesh.length)
    
    globalMesh = mesh

    window.document.getElementById("progress").innerHTML = "Preparing download..."
    
    downloadBlob(name+".stl", new Blob([makeMeshByteArray(mesh)], {type: "application/octet-stream"}));
}

function processRunfile(response) {
    var lines = response.split(/\r?\n/)
   
    window.document.getElementById("progress").innerHTML = "Processing runfile..."

    var size = 0
    var raster
    
    message = ""
    
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i].split(" ")
        if (line[0] == "run" && line[1]=="j") {
            message += "steps: "+line[2]+"<br/>"
        }
        else if (line[0] == "param") {
            var params = { "a": "alpha", "b": "beta", "g": "gamma", "k": "kappa", "m": "mu", "r": "rho", "s": "sigma", "n": "resolution" }
            if (params[line[1]]) {
                message += params[line[1]]+": "+line[2]+"<br/>"
                if (line[1] == "n") {
                    size = parseInt(line[2])
                    raster = []
                    for (var x = 0 ; x < size ; x++) {
                        raster[x] = []
                        for (var y = 0 ; y < size ; y++) 
                            raster[x][y] = 0
                    }
                }
            }
        }
        else if (line[0]=='y') {
            y = parseInt(line[1])
            for (var x = 0 ; x < size ; x++) {
                raster[x][y] = parseInt(line[2+x])
            }
        }
    }

    console.log("runfile processed")

    if (! size) {
        window.document.getElementById("output").innerHTML = "Badly formed data."
        return
    }
    else {
        window.document.getElementById("output").innerHTML = message
    }
    
    console.log("processing raster")
    
    setTimeout( function() { processRaster(raster, size) }, 1 )
}

function process(document) {
    console.log("Scraping")
    var found = false;
    links = document.getElementsByTagName('a')
    for (var i=0;i<links.length;i++) {
        matches = links[i].href.match("/flakes/snowflake-.*\\.txt")
        if (matches) {            
            found = true
            var xhr = new XMLHttpRequest()
            xhr.onload = function() {
                processRunfile(xhr.response)
            }
            url = "http://mkweb.bcgsc.ca/snowflakes"+matches[0]
            xhr.open("GET", corsCircumvent(url))
            xhr.responseType = "text"
            xhr.send()
            window.document.getElementById("progress").innerHTML = "Loading..."
            break
        }
    }
    if (!found) {
        alert("Snowflake not found")
    }
}

function load() {
    diameter = parseFloat(window.document.getElementById("diameter").value)
    minThickness = parseFloat(window.document.getElementById("thinnest").value)
    maxThickness = parseFloat(window.document.getElementById("thickest").value)
    levels = parseInt(window.document.getElementById("levels").value)
    name = window.document.getElementById("name").value.toLowerCase()
    if (levels < 1 || minThickness >= maxThickness) 
        levels = 1
        
    var xhr = new XMLHttpRequest()
    xhr.onload = function() {
        process(xhr.responseXML)
    }
    url = "http://mkweb.bcgsc.ca/snowflakes/flake.mhtml?flake="+name
    xhr.open("GET", corsCircumvent(url))
    xhr.responseType = "document"
    xhr.send()
    document.getElementById("progress").innerHTML = "Searching..."
    document.getElementById("output").innerHTML = ""
}

function setVector(view, position, vector) {
    view.setFloat32(position, vector[0], true);
    view.setFloat32(position+4, vector[1], true);
    view.setFloat32(position+8, vector[2], true);
}

function makeMeshByteArray(triangles) {
    totalTriangles = triangles.length
        
    var data = new ArrayBuffer(84 + totalTriangles * TRIANGLE_SIZE);
    var view = new DataView(data);
    view.setUint32(80, totalTriangles, true);
    var offset = 84;
    for (var i=0; i<totalTriangles; i++) {
        setVector(view, offset, [0,0,0]); // normal (TODO)
        setVector(view, offset+12, triangles[i][0]); // v1
        setVector(view, offset+12*2, triangles[i][1]); // v2
        setVector(view, offset+12*3, triangles[i][2]); // v3
        offset += TRIANGLE_SIZE;
    }
    return view.buffer;
}

function downloadBlob(name,blob) {
    var link = document.createElement('a');
    document.body.appendChild(link);
    link.download = name;
    link.href = window.URL.createObjectURL(blob);
    link.onclick = function(e) {
        setTimeout(function() {
            window.URL.revokeObjectURL(link.href);
        }, 1600);
    };
    link.click();
    try {
        link.remove();
    }
    catch(err) {}  
    try {
        document.body.removeChild(link);
    }
    catch(err) {}
}
</script>

</html>
