<!DOCTYPE html>
<html>
<head><title>Snowflake to STL</title></head>
</head>
<body>
Snowflake name: <input id="name" type="text" value="morptel"/> (find it <a href="http://mkweb.bcgsc.ca/snowflakes">here</a>)<br/>
Diameter: <input id="diameter" type="number" value="190" min="0.1" step="5" max="100000"/>mm <br/>
Minimum thickness: <input id="thinnest" type="number" step="0.1" value="1.5" min="0.1" max="100000"/>mm<br/> 
Maximum thickness: <input id="thickest" type="number" step="0.1" value="4" min="0.1" max="100000"/>mm<br/> 
Number of levels: <input id="levels" type="number" step="1" min="1" max="1000" value="1"/><br/>
<button id="Go" onClick="load()">Generate!</button><br/>
<div id="output"></div>
<div id="progress"></div>
</body>

<script>
function corsCircumvent(url) {
    return "http://api.allorigins.ml/get?method=raw&url="+encodeURIComponent(url)+"&callback=?"
}

var diameter
var minThickness
var maxThickness
var levels

var CORNERS = [[1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1], [1, -1]]

function displayX(x,y,size) {
    return ((x-2*size) + (y-2*size) / 2.) * Math.sqrt(3)
}

function displayY(x,y,size) {
    return (y-2*size) * 1.5
}

function getScale(raster, size) {
    var maxRadiusSq = 0;
    for (var x = 0 ; x < size ; x++)
        for (var y = 0; y < size ; y++)
            if (raster[x][y]>0)
                maxRadiusSq = max(maxRadiusSq,Math.pow(displayX(x,y,size),2)+Math.pow(displayY(x,y,size),2))
    return diameter/(2*(0.5+Math.sqrt(maxRadiusSq)))
}

function makeMesh(raster, size, prevHeight, height, prevThickness, thickness) {
    var maxCoord = 2*size+2
    
    function encodePoint(p) {
        return p[0] + maxCoord*p[1]
    }
    
    function decodePoint(c) {
        return [c%maxCoord, Math.floor(c/maxCoord)]
    }
    
    var scale = getScale(raster, size)

    function xyToDisplay(xy) {
        return [scale*displayX(xy[0],xy[1],size),scale*displayY(xy[0],xy[1],size)]
    }

    function xyEncodedToDisplay(xye) {
        return xyToDisplay(decodePoint(xye))
    }
    
    function raiseTo(a,h) {
        return [a[0],a[1],h]
    }
    
    function addTriangleAt(h, a, b, c) {
        mesh.push(raiseTo(a,h),raiseTo(b,h),raiseTo(c,h)) 
    }
    
    function addSideMesh(a, b) {
        mesh.push([raiseTo(a,prevThickness), raiseTo(b,prevThickness), raiseTo(b,thickness)])
        mesh.push([raiseTo(a,prevThickness), raiseTo(b,thickness), raiseTo(a,thickness)])
    }

    var segments = []
    
    for (var x = 0 ; x < size; x++)
        for (var y = 0 ; y < size ; y++) {
            if (prevHeight < raster[x][y] && raster[x][y] <= height) {
                var center = xyToDisplay([2*x,2*y])
                for (var i=0; i<6; i++) {
                    c0 = CORNERS[i]
                    c1 = CORNERS[(i+1)%6]
                    p0 = [2*x+c0[0],2*y+c0[1]]
                    p1 = [2*x+c1[0],2*y+c1[1]]
                    s0 = encodePoint(p0)
                    s1 = encodePoint()
                    if (s1 in segments && segments[s1] == s0) {
                        delete segments[s1]
                    }
                    else {
                        segments[s0] = s1
                    }
                    addTriangleAt(0, center, xyToDisplay(p1), xyToDisplay(p0)])
                    addTriangleAt(thickness, center, xyToDisplay(p0), xyToDisplay(p1)])
                }
            }
        }
        
    while(true) {
        var first = null;
        for (var key in segments) {
            if (segments[key] != null) {
                first = key;
                break;
            }
        }
        
        if (first == null)
            break;
            
        var p = segments[first]
        var p0 = p
        addSideMesh(xyEncodedToDisplay(parseInt(first)), xyEncodedToDisplay(p))
        segments[first] = null
        
        var n = 2
        
        while(true) {
            var p1 = segments[p]
            segments[p] = null
            if (p == p0) {
                break
            }
            
            addSideMesh(xyEncodedToDisplay(p0), xyEncodedToDisplay(p1))
        }
    }
    
    return mesh
}

function processRaster(raster, size) {
    var minHeight = Number.POSITIVE_INFINITY
    var maxHeight = Number.NEGATIVE_INFINITY
    
    for (var x = 0 ; x < size ; x++) {
        for (var y = 0; y<size ; y++) {
            if (raster[x][y] > 0) {
                minHeight = min(minHeight, raster[x][y])
                maxHeight = max(minHeight, raster[x][y])
            }
        }
    }

    var mesh = []
    var prevHeight = 0
    var prevThickness = 0
    
    for (var level=0; level<levels; level++) {
        var thickness
        if (levels == 1) {
            thickness = maxThickness
        }
        else {
            thickness = minThickness+level*(maxThickness-minThickness)/(levels-1)
        }
        var height = minHeight+level*(maxHeight-minHeight)/levels
        mesh.concat(makeMesh(raster, size, prevHeight, height, prevThickness, thickness))
        prevHeight = height
        prevThickness = thickness
    }
    
    emitMesh(mesh)
}

function processRunfile(response) {
    var lines = response.split(/\r?\n/)
    
    var message = "Found!<br/><br/>"
    var size = 0
    var raster
    
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i].split(" ")
        if (line[0] == "run" && line[1]=="j") {
            message += "steps: "+line[2]+"<br/>"
        }
        else if (line[0] == "param") {
            var params = { "a": "alpha", "b": "beta", "g": "gamma", "k": "kappa", "m": "mu", "r": "rho", "s": "sigma", "n": "resolution" }
            if (params[line[1]]) {
                message += params[line[1]]+": "+line[2]+"<br/>"
                if (line[1] == "n") {
                    size = parseInt(line[2])
                    raster = []
                    for (var x = 0 ; x < size ; x++) {
                        raster[x] = []
                        for (var y = 0 ; y < size ; y++) 
                            raster[x][y] = 0
                    }
                }
            }
        }
        else if (line[0]=='y') {
            y = parseInt(line[1])
            for (var x = 0 ; x < size ; x++) {
                raster[x][y] = parseInt(line[2+x])
            }
        }
    }

    if (! size) {
        window.document.getElementById("output").innerHTML = "Badly formed data."
        return
    }
    else {
        window.document.getElementById("output").innerHTML = message
    }
    
    mesh = processRaster(raster, size)
}

function process(document) {
    var found = false;
    links = document.getElementsByTagName('a')
    for (var i=0;i<links.length;i++) {
        matches = links[i].href.match("/flakes/snowflake-.*\\.txt")
        if (matches) {            
            found = true
            var xhr = new XMLHttpRequest()
            xhr.onload = function() {
                processRunfile(xhr.response)
            }
            url = "http://mkweb.bcgsc.ca/snowflakes"+matches[0]
            xhr.open("GET", corsCircumvent(url))
            xhr.responseType = "text"
            xhr.send()
            window.document.getElementById("progress").innerHTML = "Loading..."
            break
        }
    }
    if (!found) {
        alert("Snowflake not found")
    }
}

function load() {
    diameter = parseFloat(window.document.getElementById("diamater").value)
    minThickness = parseFloat(window.document.getElementById("thinnest").value)
    maxThickness = parseFloat(window.document.getElementById("thickest").value)
    levels = parseInt(window.document.getElementById("levels").value)
    if (levels < 1 || minThickness >= maxThickness) 
        levels = 1
    
    var xhr = new XMLHttpRequest()
    xhr.onload = function() {
        process(xhr.responseXML)
    }
    url = "http://mkweb.bcgsc.ca/snowflakes/flake.mhtml?flake="+window.document.getElementById("name").value.toLowerCase()
    xhr.open("GET", corsCircumvent(url))
    xhr.responseType = "document"
    xhr.send()
    document.getElementById("progress").innerHTML = "Searching..."
    document.getElementById("output").innerHTML = ""
}

// TODO: fix multiple Generate presses
</script>


</html>
