<!DOCTYPE html>
<html>
<head><title>Snowflake to STL</title></head>
</head>
<body>
Snowflake name: <input id="name" type="text" value="morptel"/> (find it <a href="http://mkweb.bcgsc.ca/snowflakes">here</a>)<br/>
Diameter: <input id="diameter" type="number" value="190" min="0.1" step="5" max="100000"/>mm <br/>
Minimum thickness: <input id="thinnest" type="number" step="0.1" value="1.5" min="0.1" max="100000"/>mm<br/> 
Maximum thickness: <input id="thickest" type="number" step="0.1" value="4" min="0.1" max="100000"/>mm<br/> 
Number of levels: <input id="levels" type="number" step="1" min="1" max="10" value="1"/><br/>
<button id="Go" onClick="load()">Generate!</button><br/><br/>
<div id="output"></div><br/>
<div id="progress"></div>
</body>

<script>

function corsCircumvent(url) {
    //return "http://crossorigin.me/"+encodeURIComponent(url)
    //return "http://cors-proxy.htmldriven.com/?url="+encodeURIComponent(url)
    return "http://api.allorigins.ml/get?method=raw&url="+encodeURIComponent(url)+"&callback=?"
}

var TRIANGLE_SIZE = (3+3*3)*4+2
var diameter
var minThickness
var maxThickness
var levels
var name

var CORNERS = [[1,1], [-1,2], [-2,1], [-1,-1], [1,-2], [2,-1]];
function displayX(x,y,size) {
    x -= size
    y -= size
    return (x+0.5*y)*Math.sqrt(3) // ((x-2*size) + (y-2*size) / 2.) * Math.sqrt(3)
}

function displayY(x,y,size) {
    y -= size
    return y*1.5 // (y-2*size) * 1.5
}

function getScale(raster, size) {
    var maxRadiusSq = 0;
    for (var x = 0 ; x < size ; x++)
        for (var y = 0; y < size ; y++)
            if (raster[x][y]>0)
                maxRadiusSq = Math.max(maxRadiusSq,Math.pow(displayX(x,y,size),2)+Math.pow(displayY(x,y,size),2))
    return diameter/(2*(0.5+Math.sqrt(maxRadiusSq)))
}

function addLevel(mesh, raster, size, prevHeight, height, prevThickness, thickness) {
    var maxCoord = 100000
    
    var scale = 1 // getScale(raster, size)

    function xyToDisplay(xy) {
        return [scale*displayX(xy[0],xy[1],size),scale*displayY(xy[0],xy[1],size)]
    }

    function raiseTo(a,h) {
        return [a[0],a[1],h]
    }
    
    function addTriangle(a,b,c) {
        var tri = new Float32Array(9)
        
        for (var i=0 ; i < 3 ; i++) {
            tri[i] = a[i]
        }
        for (var i=0 ; i < 3 ; i++) {
            tri[3+i] = b[i]
        }
        for (var i=0 ; i < 3 ; i++) {
            tri[6+i] = c[i]
        }

        mesh.push(tri)
    }
    
    function addTriangleAt(h, a, b, c) {
        addTriangle(raiseTo(a,h),raiseTo(b,h),raiseTo(c,h)) 
    }
    
    function addSideMesh(a, b) {
        addTriangle(raiseTo(a,prevThickness), raiseTo(b,prevThickness), raiseTo(b,thickness))
        addTriangle(raiseTo(a,prevThickness), raiseTo(b,thickness), raiseTo(a,thickness))
    }

    var segmentSet = new Set()
    
    for (var x = 0 ; x < size; x++)
        for (var y = 0 ; y < size ; y++) {
            if (prevHeight < raster[x][y]) {
                var center = xyToDisplay([2*x,2*y])
                for (var i=0; i<6; i++) {
                    var c0 = CORNERS[i]
                    var c1 = CORNERS[(i+1)%6]
                    var p0 = [2*x+c0[0],2*y+c0[1]]
                    var p1 = [2*x+c1[0],2*y+c1[1]]
                    
                    var rev = p1[0]+","+p1[1]+","+p0[0]+","+p0[1]
                    
                    if (segmentSet.has(rev)) {
                        segmentSet.delete(rev)
                    }
                    else {
                        segmentSet.add(p0[0]+","+p0[1]+","+p1[0]+","+p1[1])
                    }
                    
                    if (raster[x][y] <= height) {
                        addTriangleAt(0, center, xyToDisplay(p1), xyToDisplay(p0))
                        addTriangleAt(thickness, center, xyToDisplay(p0), xyToDisplay(p1))
                    }
                }
            }
        }
        
    console.log("Meshing edges")
    segments = []
     
    segmentSet.forEach(function(seg) {
        var points = seg.split(",")
        addSideMesh(xyToDisplay([parseInt(points[0]),parseInt(points[1])]), xyToDisplay([parseInt(points[2]),parseInt(points[3])]))
    })
   
}

function processRaster(raster, size) {
    window.document.getElementById("progress").innerHTML = "Meshing..."

    var minHeight = Number.POSITIVE_INFINITY
    var maxHeight = Number.NEGATIVE_INFINITY
    
    for (var x = 0 ; x < size ; x++) {
        for (var y = 0; y<size ; y++) {
            if (raster[x][y] > 0) {
                minHeight = Math.min(minHeight, raster[x][y])
                maxHeight = Math.max(maxHeight, raster[x][y])
            }
        }
    } 
    
    minHeight = 1
    maxHeight = 100

    var mesh = []
    var prevHeight = 0
    var prevThickness = 0
    
    for (var level=0; level<levels; level++) {
        var thickness
        if (levels == 1) {
            thickness = maxThickness
        }
        else {
            thickness = minThickness+level*(maxThickness-minThickness)/(levels-1)
        }
        var height = minHeight+(level+1)*(maxHeight-minHeight)/levels
        console.log("Mesh level "+(level+1)+"/"+levels+" "+prevHeight+" "+height)
        if (level == levels-1)
            height = Number.POSITIVE_INFINITY;
        addLevel(mesh, raster, size, prevHeight, height, prevThickness, thickness)
        prevHeight = height
        prevThickness = thickness
    }
    console.log("meshing done",mesh.length)
    
    window.document.getElementById("progress").innerHTML = "Preparing download..."
    
    downloadBlob(name+".stl", new Blob([makeMeshByteArray(mesh)], {type: "application/octet-stream"}));
}

function processRunfile(response) {
    var lines = response.split(/\r?\n/)
   
    window.document.getElementById("progress").innerHTML = "Processing runfile..."

    var size = 0
    var raster
    
    message = ""
    
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i].split(" ")
        if (line[0] == "run" && line[1]=="j") {
            message += "steps: "+line[2]+"<br/>"
        }
        else if (line[0] == "param") {
            var params = { "a": "alpha", "b": "beta", "g": "gamma", "k": "kappa", "m": "mu", "r": "rho", "s": "sigma", "n": "resolution" }
            if (params[line[1]]) {
                message += params[line[1]]+": "+line[2]+"<br/>"
                if (line[1] == "n") {
                    size = parseInt(line[2])
                    raster = []
                    for (var x = 0 ; x < size ; x++) {
                        raster[x] = []
                        for (var y = 0 ; y < size ; y++) 
                            raster[x][y] = 0
                    }
                }
            }
        }
        else if (line[0]=='y') {
            y = parseInt(line[1])
            for (var x = 0 ; x < size ; x++) {
                raster[x][y] = parseInt(line[2+x])
            }
        }
    }
    
    raster[Math.floor(size/2)][Math.floor(size/2)] = 255

    console.log("runfile processed")

    if (! size) {
        window.document.getElementById("output").innerHTML = "Badly formed data."
        return
    }
    else {
        window.document.getElementById("output").innerHTML = message
    }
    
    console.log("processing raster")
    
    setTimeout( function() { processRaster(raster, size) }, 0 )
}

function ready() {
    document.getElementById('Go').disabled = false
}

function process(document) {
    console.log("Scraping")
    var found = false;
    if (document) {
        links = document.getElementsByTagName('a')
        for (var i=0;i<links.length;i++) {
            matches = links[i].href.match("/flakes/snowflake-.*\\.txt")
            if (matches) {            
                found = true
                var xhr = new XMLHttpRequest()
                xhr.onload = function() {
                    processRunfile(xhr.response)
                }
                xhr.onerror = function() {
                    window.document.getElementById("progress").innerHTML = "Error loading snowflake data."
                    ready()
                }
                url = "http://mkweb.bcgsc.ca/snowflakes"+matches[0]
                xhr.open("GET", corsCircumvent(url))
                xhr.responseType = "text"
                xhr.send()
                window.document.getElementById("progress").innerHTML = "Loading..."
                break
            }
        }
    }
    if (!found) {
        window.document.getElementById("progress").innerHTML = "Snowflake not found or error in connecting."
        ready()
    }
}

function load() {
    window.document.getElementById("output").innerHTML = ""

    diameter = parseFloat(window.document.getElementById("diameter").value)
    minThickness = parseFloat(window.document.getElementById("thinnest").value)
    maxThickness = parseFloat(window.document.getElementById("thickest").value)
    levels = parseInt(window.document.getElementById("levels").value)
    name = window.document.getElementById("name").value.toLowerCase()
    if (levels < 1 || minThickness >= maxThickness) 
        levels = 1
        
    var xhr = new XMLHttpRequest()
    xhr.onload = function() {
        process(xhr.responseXML)
    }
    xhr.onerror = function() {
        window.document.getElementById("progress").innerHTML = "Snowflake not found or error in connecting."
        ready()
    }
    
    url = "http://mkweb.bcgsc.ca/snowflakes/flake.mhtml?flake="+name
    xhr.open("GET", corsCircumvent(url))
    xhr.responseType = "document"
    xhr.send()
    document.getElementById("progress").innerHTML = "Searching..."
    document.getElementById("output").innerHTML = "" 
    document.getElementById('Go').disabled = true
 //   processRaster([[]], 800)
}

/*
function setVector(view, position, vector) {
    view.setFloat32(position, vector[0], true);
    view.setFloat32(position+4, vector[1], true);
    view.setFloat32(position+8, vector[2], true);
}
*/

function makeMeshByteArray(triangles) {
    totalTriangles = triangles.length
        
    var data = new ArrayBuffer(84 + totalTriangles * TRIANGLE_SIZE);
    var view = new DataView(data);
    view.setUint32(80, totalTriangles, true);
    var offset = 84;
    for (var i=0; i<totalTriangles; i++) {
        for (var j = 0; j<3 ; j++) {
            view.setFloat32(offset, 0, true)
            offset += 4
        }
        for (var j = 0; j<9 ; j++) {
            view.setFloat32(offset, triangles[i][j], true)
            offset += 4
        }
        offset += 2
    }
    console.log (offset,totalTriangles,84 + totalTriangles * TRIANGLE_SIZE)
    return view.buffer;
}

function downloadBlob(name,blob) {
    var link = document.createElement('a');
    document.body.appendChild(link);
    link.download = name;
    link.href = window.URL.createObjectURL(blob);
    link.onclick = function(e) {
        setTimeout(function() {
            window.URL.revokeObjectURL(link.href);
        }, 1600);
    };
    link.click();
    try {
        link.remove();
    }
    catch(err) {}  
    try {
        document.body.removeChild(link);
    }
    catch(err) {}
}
</script>

</html>
